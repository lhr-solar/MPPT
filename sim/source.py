"""
Source.py

Author: Matthew Yu, Array Lead (2020).
Contact: matthewjkyu@gmail.com
Created: 5/24/20
Last Modified: 5/28/20
Description: This file describes the Source class, which generates input values for the Display and MPPT.
    The Source is time agnostic. The output is purely dependent on current conditions.
"""
from math import exp
from numpy import log as ln
class Source:
    v_out       = 0
    i_out       = 0
    irradiance  = 0
    temperature = 0
    load        = 0
    idx         = 0

    arr_cycle   = []
    arr_irrad   = []
    arr_temp    = []
    arr_load    = []

    def __init__(self):
        """
        init
        """
        return

    def setup_f(self, file_name=""):
        """
        setup_f (file) TODO:determine file structure, populate example file with data, and implement function to load it
        A data structure in the Source is populated from a file.

        Args:
            - file_name (string): file path to data file. A data file is formatted with the following types of values:
                - irradiance (W/m^2)
                - temperature (C)
                - load (W/s)

        Returns:
            - success (True) or failure (False) (bool)

        Note: efficiency losses are not considered (as of yet) in the Source model.
        """
        self.arr_cycle  = []
        self.arr_irrad  = []
        self.arr_temp   = []
        self.arr_load   = []
        return False
    
    def setup_a(self, regime):
        """
        setup_a (array)
        Populates Source data structure using an array of values.

        Args:
            - regime (list of lists): contains a list of events.
                - cycle | temp | TODO: NOT IMPLEMENTED

        Returns:
            - None
        """
        for event in regime:
            cycle = event[0]
            irrad = 0
            temp = event[1]
            load = 0
            
            self.arr_cycle.append(cycle)
            self.arr_irrad.append(irrad)
            self.arr_temp.append(temp)
            self.arr_load.append(load)

        print(self.arr_cycle)
        print(self.arr_temp)

    def setup_i(self, irradiance=0, temperature=0, load=0):
        """
        setup _i (impulse)
        Populates a data structure with user-set variables
        
        Args:
            - irradiance (float): light intensity on the cell (W/m^2)
            - temperature (float): surface temperature of the cell (C)
            - load (float): load on the system (W/s) NOTE: UNUSED

        Returns:
            - None

        Note: efficiency losses are not considered (as of yet) in the Source model.
        """
        self.irradiance = irradiance
        self.temperature = temperature
        self.load = load

    def iterate(self, v_in):
        """
        iterate
        Using source conditions, calculate the source voltage and current the system should expect.
        
        Args:
            - v_in (float): input voltage

        Returns:
            - (v_out, i_out) (tuple)
        """
        # NOTE: Defaulting to sunpower 1 cell at STD conditions

        # print("Input voltage: ", v_in)
        # print("Looking for closest voltage.")

        self.v_out = v_in

        self.i_out = self.model(v_in, self.irradiance, self.temperature, self.load)
        # print("Current at voltage: ",  model(v_in))
        return [self.v_out, self.i_out]

    def iterate_t(self, v_in, cycle):
        """
        iterate_t
        Using source conditions, calculate the source voltage and current the system should expect.
        NOTE: This version uses the cycle to pull relevant source conditions generated by setup(file_name).
        
        Args:
            - v_in    (float): input voltage
            - cycle   (int): cycle to grab source data from

        Returns:
            - [v_out, i_out, irrad, temp, load] (list)
        """
        # NOTE: Defaulting to sunpower 1 cell at STD conditions

        # print("Input voltage: ", v_in)
        # print("Looking for closest voltage.")

        # try to set new conditions
        try:
            # if idx exists
            idx = self.arr_cycle.index(cycle)
            # load it
            self.v_out = v_in

            self.idx = idx
            self.irradiance = self.arr_irrad[idx]
            self.temperature = self.arr_temp[idx]
            self.load = self.arr_load[idx]
        except ValueError:
            print("[SOURCE] NOTE: Cycle does not exist in data. Interpolating data.")
            # if idx doesn't exist, grab two closest points
            idx_new = self.idx + 1
            idx_curr = self.idx
            try:
                # interpolate slope
                dCycle = (self.arr_cycle[idx_new] - self.arr_cycle[idx_curr])
                sIrr   = (self.arr_irrad[idx_new] - self.arr_irrad[idx_curr])/dCycle
                sTemp  = (self.arr_temp[idx_new] - self.arr_temp[idx_curr])/dCycle
                sLoad  = (self.arr_load[idx_new] - self.arr_load[idx_curr])/dCycle

                for i in range(0, dCycle - 1): # append entries to relevant arrays
                    insert_idx = idx_curr + i + 1
                    self.arr_cycle.insert(insert_idx,   self.arr_cycle[insert_idx - 1] + 1)
                    self.arr_irrad.insert(insert_idx,   self.arr_irrad[insert_idx - 1] + sIrr)
                    self.arr_temp.insert(insert_idx,    self.arr_temp[insert_idx - 1] + sTemp)
                    self.arr_load.insert(insert_idx,    self.arr_load[insert_idx - 1] + sLoad)
            except IndexError:
                print("[SOURCE] NOTE: Cycle does not exist in data. Reached end of regime data. Don't interpolate.")
                insert_idx = idx_curr + 1
                self.arr_cycle.insert(insert_idx,   self.arr_cycle[insert_idx - 1] + 1)
                self.arr_irrad.insert(insert_idx,   self.arr_irrad[insert_idx - 1])
                self.arr_temp.insert(insert_idx,    self.arr_temp[insert_idx - 1])
                self.arr_load.insert(insert_idx,    self.arr_load[insert_idx - 1])
                
            return self.iterate_t(v_in, cycle)


        # model most recent conditions
        self.i_out = self.model(v_in, self.irradiance, self.temperature, self.load)
        # print("Current at voltage: ",  model(v_in))
        return [self.v_out, self.i_out, self.irradiance, self.temperature, self.load]

    def get_conditions(self):
        """
        get_conditions
        Returns source conditions for data analysis.

        Args:
            - None

        Returns:
            - (irradiance, temperature, load) (tuple)

        """
        return [self.irradiance, self.temperature, self.load]

    def model(self, v_in, irr_in=0, t_in=0, ld_in=0):
        """
        model TODO: update with a more advanced model with irradiance
        Function describing the current output of a SINGLE Bin Le1 Sunpower cell given voltage and other factors.
    
        Args:
            - v_in      (float): voltage input      (V)
            - t_in      (float): temperature input  (C)
            - irr_in    (float): irradiance input   (W/m^2)
            - ld_in     (float): load input         (W)

        Returns:
            - (current out) (float)

        Ref:
            1. Modeling of photovoltaic module and experimental determination of serial resistance (Benghanem et Alamri)
                - Section 2.1, Explicit Model        
                - model(v) = i_sc*( 1 - C_1*( exp( v/(C_2*v_oc) ) - 1 ) )
                    ~ C_1 = (1 - C_4/i_sc)*exp( -C_3/(C_2*v_oc) )
                    ~ C_2 = ((C_3/v_oc) - 1) / ln(1 - C_4/i_sc)
                    ~ https://www.pveducation.org/pvcdrom/solar-cell-operation/effect-of-temperature
                        - for silicon solar cell
                        - V_OC = .721 - (2.2*.001)*(t-25)
                        - I_SC = 6.15 + (.06*.001)*(t-25)
            2. Modeling and simulation of photovoltaic arrays (Banu et Istrate)
                - Section 2, Simulink Model of Solar Cell
                - TODO: Implement this?

        C_3 = maximal voltage
        C_4 = maximal current
        """
        k = 0.92 # manufacturing efficiency loss (8% according to test data)

        # open circuit voltage and short circuit current dependence on temperature
        v_oc = .721 - (2.2*.001)*(t_in-25)
        i_sc = 6.15 + (.06*.001)*(t_in-25)

        C_3 = 0.817 # maximal voltage - determined by tuning parameters in desmos until maxppt is reached
        C_4 = -100  # maximal current

        C_2 = ((C_3/v_oc) - 1) / ln(1 - C_4/i_sc)
        C_1 = (1 - C_4/i_sc)*exp( -C_3/(C_2*v_oc) )
        # default explicit model
        model = i_sc*( 1 - C_1*( exp( v_in/(C_2*v_oc) ) - 1 ) )

        print("Model: [I=", model, "|@V=", v_in, "IRR=", irr_in, "TEMP=", t_in, "LOAD=", ld_in, "]")

        # losses in efficiency as a result of manufacturing (lamination, etc)
        model2 = model * k
        
        return model2
    
