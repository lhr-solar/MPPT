"""
Source.py

Author: Matthew Yu, Array Lead (2020).
Contact: matthewjkyu@gmail.com
Created: 5/24/20
Last Modified: 5/27/20
Description: This file describes the Source class, which generates input values for the Display and MPPT.
    The Source is time agnostic. The output is purely dependent on current conditions.
"""
from math import exp
from numpy import log as ln
class Source:
    v_out       = 0
    i_out       = 0
    irradiance  = 0
    temperature = 0
    load        = 0

    arr_cycle   = []
    arr_irrad   = []
    arr_temp    = []
    arr_load    = []
    def __init__(self):
        """
        init
        """
        return

    def setup(self, file_name=""):
        """
        TODO:read_data 
        A data structure in the Source is populated from a file.

        Args:
            - file_name (string): file path to data file. A data file is formatted with the following types of values:
                - irradiance (W/m^2)
                - temperature (C)
                - load (W/s)
        Returns:
            - success (True) or failure (False) (bool)
        Note: efficiency losses are not considered (as of yet) in the Source model.
        """
        self.arr_cycle  = []
        self.arr_irrad  = []
        self.arr_temp   = []
        self.arr_load   = []
        return False

    def setup(self, irradiance=0, temperature=0, load=0):
        """
        setup 
        Populates a data structure with user-set variables
        
        Args:
            - irradiance (float): light intensity on the cell (W/m^2)
            - temperature (float): surface temperature of the cell (C)
            - load (float): load on the system (W/s) NOTE: UNUSED
        Returns:
            - None

        Note: efficiency losses are not considered (as of yet) in the Source model.
        """
        self.irradiance = irradiance
        self.temperature = temperature
        self.load = load

    def iterate(self, v_in):
        """
        iterate
        Using source conditions, calculate the source voltage and current the system should expect.
        
        Args:
            - v_in (float): input voltage
        Returns:
            - (v_out, i_out) (tuple)
        """
        # NOTE: Defaulting to sunpower 1 cell at STD conditions

        # print("Input voltage: ", v_in)
        # print("Looking for closest voltage.")

        self.v_out = v_in

        self.i_out = self.model(v_in, self.irradiance, self.temperature, self.load)
        # print("Current at voltage: ",  model(v_in))
        return [self.v_out, self.i_out]

    def iterate_t(self, v_in, cycle):
        """
        iterate (overloaded)
        Using source conditions, calculate the source voltage and current the system should expect.
        NOTE: This version uses the cycle to pull relevant source conditions generated by setup(file_name).
        
        Args:
            - v_in    (float): input voltage
            - cycle     (int): cycle to grab source data from
        Returns:
            - [v_out, i_out, irrad, temp, load] (list)
        """
        # NOTE: Defaulting to sunpower 1 cell at STD conditions

        # print("Input voltage: ", v_in)
        # print("Looking for closest voltage.")
        try:
            self.v_out = v_in

            idx = self.arr_cycle.index[cycle]
            irrad = self.arr_irrad[idx]
            temp = self.arr_temp[idx]
            load = self.arr_load[idx]
            self.i_out = self.model(v_in, irrad, temp, load)
            # print("Current at voltage: ",  model(v_in))
            return [self.v_out, self.i_out, irrad, temp, load]
        except ValueError:
            print("[SOURCE] Error: Cycle does not exist in data.")

    def get_conditions(self):
        """
        get_conditions
        Returns source conditions for data analysis.

        Args:
            - None
        Returns:
            - (irradiance, temperature, load) (tuple)

        """
        return [self.irradiance, self.temperature, self.load]

    def model(self, v_in, irr_in=0, t_in=0, ld_in=0):
        """
        model
        function describing the current output of a single Bin Le1 Sunpower cell given voltage and other factors.
        Taken from https://www.sciencedirect.com/science/article/pii/S1658365512600120, section 2.1, Explicit Model.
        Im/Vm constants played with until they matched cell specs for the power point.
        
        model(v) = i_sc*( 1 - C_1*( exp( v/(C_2*v_oc) ) - 1 ) )
        C_1 = (1 - C_4/i_sc)*exp( -C_3/(C_2*v_oc) )
        C_2 = ((C_3/v_oc) - 1) / ln(1 - C_4/i_sc)

        V_OC = .721 - (2.2*.001)*(t-25) # for silicon solar cell
        I_SC = 6.15 + (.06*.001)*(t-25) # https://www.pveducation.org/pvcdrom/solar-cell-operation/effect-of-temperature

        C_3 = maximal voltage
        C_4 = maximal current

        TODO: include inputs for irradiance, temperature, and their transformation on the model

        Args:
            - v_in (float): voltage input
            - t_in (float): temperature input
        Returns:
            - (current out) (float)
        """
        k = 0.92 # manufacturing efficiency loss (8% according to test data)
        v_oc = .721 - (2.2*.001)*(t_in-25)
        i_sc = 6.15 + (.06*.001)*(t_in-25)

        C_3 = 0.817 # maximal voltage
        C_4 = -100 # maximal current

        C_2 = ((C_3/v_oc) - 1) / ln(1 - C_4/i_sc)
        C_1 = (1 - C_4/i_sc)*exp( -C_3/(C_2*v_oc) )
        # default explicit model
        model = i_sc*( 1 - C_1*( exp( v_in/(C_2*v_oc) ) - 1 ) )

        print("Model: [I=", model, "|@V=", v_in, "IRR=", irr_in, "TEMP=", t_in, "LOAD=", ld_in, "]")

        # losses in efficiency as a result of manufacturing (lamination, etc)
        model2 = model * k

        # TODO: include transformation for irradiance change, temperature
        
        return model
    
